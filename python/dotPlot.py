import numpy as np
import pylab as plt

def generatePlotValues(x, width=3, space=0.1):
    
    vs = space# / 3.0
    vos = ((width - 1) / 2.0) * space
    
    if not x[0] == 0:    
        if x[0] % 2 == 0:
            ret = [[i * vs - vos for i in range(width)], [space / 2.0 for i in range(width)]]
            os = space / 2.0
            k = 1
        else:        
            ret = [[i * vs - vos for i in range(width)], [0 for i in range(width)]]
            os = 0
            k = 0
                        
        for m in range(1, x[0]):
            ret[0] += [i * vs - vos for i in range(width)]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k for i in range(width)]
            k += 1
        
        if x[1] == 1:
            ret[0] += [0]
            k += 1
            ret[1] += [(space * (k / 2 + 1) - os) * abs((-1)**(k))]
            
        if x[1] == 2:
            ret[0] += [0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            k += 1
            ret[0] += [0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            
        if x[1] == 3:
            ret[0] += [0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            k += 1
            ret[0] += [-space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            ret[0] += [space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            
        if x[1] == 4:
            ret[0] += [-space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            ret[0] += [space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            k += 1
            ret[0] += [-space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            ret[0] += [space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            
            
    else:
        if x[1] == 1:
            ret = [[0], [0]]  
        elif x[1] == 2:
            ret = [[0, 0],
                   [space / 2.0, -space / 2.0]]
        elif x[1] == 3:
            k = 0
            os = space / 2.0
            ret = [[0],
                   [(space * (k / 2 + 1) - os)  * (-1)**k]]
            k += 1
            ret[0] += [- space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            ret[0] += [space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            
        elif x[1] == 4:
            k = 0
            os = space / 2.0
            ret = [ [- space / 2.0],
                    [(space * (k / 2 + 1) - os)  * (-1)**k]]
            ret[0] += [space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            k += 1
            ret[0] += [- space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
            ret[0] += [space / 2.0]
            ret[1] += [(space * (k / 2 + 1) - os)  * (-1)**k]
        
    return ret
      

def plotDotPlot(h, space=0.1, os=0, width=3, **kwargs):
    """
    Args:
        h (np.hist)
                histogram generated by np.hist
        space (float)
                spacing between dots (horizontal and vertical)
        os (float)
                vertical offset of the entire plot
        kwargs (dict)
                kwargs of matplotlib scatter function
    """
    
    plotRawVal = [[x/width, x % width] for x in h[0]]
    
    for i in range(len(plotRawVal)):
        if not plotRawVal[i] == [0,0]:
            val = generatePlotValues(plotRawVal[i], width=width)
            plt.scatter(x=[x + os for x in val[0]], y=[x + (i + 1) for x in val[1]], **kwargs)
